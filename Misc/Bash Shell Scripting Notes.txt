Shell Scripting (Bash Shell) Notes:
-----------------------------------

Shell Scripting - a collection of commands that are all listed inside a file. All of the commands that would normally be used at the 
				command line can be placed into this file (into a script) and the script can then be executed. This causes the shell 
				to execute each line in the script (line by line) as if it was actually being typed in line by line. This is a handy 
				way to take a lot of commands that would be hard to remember and to "pre-bake" the commands into a file for later 
				execution.

Shell Scripting is INTERPRETED, so this means there is no compiling, no variable declaration and no memory management. 				

There is a set of SPECIAL PARAMETERS for every script that is runs:
$ - The process ID of the script itself (every running process has a unique PID)
? -  The return value of the previously terminated command or script 
# - The number of arguments (positional parameters) given when a script is executed 
1 - The first argument (positional parameter) as of when the script was ran
2 - The second argument (positional parameter) as of when the script was ran 
3,4, etc.
@ - Returns all arguments (positional parameters) concatenatedd with spaces, as one string
_ - (Underscore) is the last argument of the previous command, after expansion  

CTRL-C will kill a script immediately. 

There are 3 uses for the $ symbol:
1) To get the value out of a variable: $myString
2) To establish a subshell: myAge=$(expr 25 + 5) 
3) The name of a variable which is always there to hold the process ID: touch newFile$


Trapping Signals:
-----------------

The trap command can be used to catch signals (like SIGINT generated by hitting CTRL+C) and clean up your mess - see program "trapCommand". 
Syntax: trap <code to execute> list-of-signals 



Subshells:
----------

If we want to increment, or set to an arbitrary value, we first have to calculate that value and return it AS TEXT to the script, 
then the script can continue. These are executed as entirely separate shells (called subshells) in their own processes that run and return. 

2 Ways to use to do command substitution with subshells:
Example 1: i=`expr $i + 1`  <-- Use backticks, this is the old/original method
Example 2: i=$(expr $i + 1) <-- Preferred method, POSIX compliant, doesn't need escaping when nested 

Note: 2 different ways to do arithmatic expansion without the expr command:
Example 1: i=$(( 9 + 9 )) 
Example 2: (( i++ ))



Error Checking:
---------------

By adding -e to the shebang line, this will exit the shell if any commands have a problem (i.e. return a non-zero value after executing). 
In the following example, this will stop the script if the copy command returns a non-zero number (if the copy failed for some reason). 
Therefore, the remove command will only be executed if the previous command was 0.
Example 1:
#!/bin/bash -e 
cp importantFile importantFile_updated
rm -f importantFile    <-- Will only be executed if the result of the previous command was 0

Error Checking Example 2:
#!/bin/bash 
if cp importantFile importantFile_updated
then 
	rm -f importantFile
else
	echo "copy failed" 1>&2  <-- This bash command means: take anything going to file descriptor 1 (stdout) and redirect it to file descriptor 2 (stderr) for the duration of this command
	exit 1
fi 



if-statement syntax:
--------------------

if -command list-   <-- if command list returns 0...
then
	-command list- 
elif -command list-  <-- else if command list returns 0...
then 
	-command list-
else                 <-- otherwise 
	-command list- 
fi                   <-- close the if-statement 




Shell Script Commands:
----------------------

exit 		The exit bash shell command takes an integer, and the integer that it takes as its first argument, is the value that will be 
			reported in the ? variable. 0 is traditionally interpreted to mean that there were no errors. 
			Example:
			$ echo hello world
			hello world
			$ echo $?
			0
			$ cd %=^2%21
			=^2%21: No such file or directory.
			$ echo $?
			1
			
test 		The test command can test for file existence, equality of strings, length, permissions, number equality, etc.
			Example:
			$ test 1 -ne 2  <-- tests if 1 is not equal to 2
			$ echo $?
			0               <-- Value of 0 shows that the outcome of the test is TRUE, 1 is not equal to 2 
			$ test 1 -ne 1
			$ echo $?
			1               <-- Value of 1 shows that the outcome of the test is FALSE, 1 does equal 1 
			
read 		Grabs a line of text from the input (reads until it hits a new line character) and then it returns it and stuffs it 
			into the variable which is its first argument. 
			
cut 		Extracts columns of data out of a file. 
			Example: cut -c 1 $inputFile > $tempColFile
					 cut -c 3 $inputFile >> $tempColFile
			The -c switch says that we want to designate which column we are extracting by character. This means that the number right 
			after -c is the number of the character that we want out. 
			Note: If you have fields such as numbers of different digit lengths (instead of single characters) that you want out, then 
			we will use the -f switch instead of the -c switch. The field switch will then just skip over whitespace (such as tabs) between 
			the numbers. So before with -c when we had to get the characters at 1 3 5...now with -f we just get the fields at 1 2 3...
			
tr 			This function transfors all newlines (\n) into tabs (\t) - or any other transformation that you want. Use this to convert a column 
			file into a row file.
			Example: cat $tempColFile | tr '\n' '\t' > "$tempRow$$" 
			
